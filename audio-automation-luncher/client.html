<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REMOTE-MIC Control Panel</title>
    <script>
    if (window.require) {
        require('./index.js')
        import('./node_modules/socket.io/client-dist/socket.io.esm.min.js').then(m=>window.io = m.io)
    } else {
        import('./socket.io/socket.io.esm.min.js').then(m=>window.io = m.io)
    }
    </script>
    <script>
    
    // WebSocket chat/signaling channel variables.

    var connection = null;
    var clientID = 0;
    
    // The media constraints object describes what sort of stream we want
    // to request from the local A/V hardware (typically a  and
    // microphone). Here, we specify only that we want both audio and
    // video; however, you can be more specific. It's possible to state
    // that you would prefer (or require) specific resolutions of video,
    // whether to prefer the user-facing or rear-facing camera (if available),
    // and so on.
    //
    // See also:
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
    //
    
    var mediaConstraints = {
      audio: true,            // We want an audio track
      // video: {
      //   aspectRatio: {
      //     ideal: 1.333333     // 3:2 aspect is preferred
      //   }
      // }
    };
    
    var rtcPeerConnection = null; // RTCPeerConnection
    
    var mediaStream = null;       // MediaStream
    
    // Output logging information to console.
    function log(text) {
      var time = new Date();
    
      console.log("[" + time.toLocaleTimeString() + "] " + text);
    }
    
    // Output an error message to console.
    
    function log_error(text) {
      var time = new Date();
    
      console.trace("[" + time.toLocaleTimeString() + "] " + text);
    }
    
    // Send a JavaScript object by converting it to JSON and sending
    // it as a message on the WebSocket connection.
        
    // Open and configure the connection to the WebSocket server.
    
    function connect() {
      serverUrl = "wss://localhost:8080/webRTC";
    
      log(`Connecting to server: ${serverUrl}`);
      //connection = new WebSocket(serverUrl, "json");
      connection = io(serverUrl, { transports: ['websocket'], rejectUnauthorized: false });
      connection.on("connect", () => {
        document.getElementById("text").disabled = false;
        document.getElementById("send").disabled = false;
      });
    
      connection.on('error', function(evt) {
        console.dir(evt);
      })
      connection.on('webrtc', function(evt) {
        console.log('webrtc',evt)
      })
      // onConnect emit socketid to namespace      
      // connection.on('id', (clientID) => {
      //   connection.emit('id', {
      //     name: document.getElementById("name").value,
      //     date: Date.now(),
      //     id: clientID,
      //     type: "username"
      //   });
      // })
      connection.on('join', socketId => {

      })
      
      connection.on('message', function(msg) {
        
        var chatBox = document.querySelector(".chatbox");
        var text = "";
        
        log("Message received: ");
        console.dir(msg);
        var time = new Date(msg.date);
        var timeStr = time.toLocaleTimeString();
    
        switch(msg.type) {   
          case "video-offer":  // Invitation and offer to chat
            acceptOffer(msg);
            break;
    
          case "video-answer":  // Callee has answered our offer
            var desc = new RTCSessionDescription(msg.sdp);
            await rtcPeerConnection.setRemoteDescription(desc).catch(reportError);           
            break;
    
          case "new-ice-candidate": // A new ICE candidate has been received
            handleNewICECandidateMsg(msg);
            break;
    
          case "hang-up": // The other peer has hung up the call
            handleHangUpMsg(msg);
            break;
    
          // Unknown message; output to console for debugging.
    
          default:
            log_error("Unknown message received:");
            log_error(msg);
        }
    
        // If there's text to insert into the chat buffer, do so now, then
        // scroll the chat panel so that the new text is visible.
    
        if (text.length) {
          chatBox.innerHTML += text;
          chatBox.scrollTop = chatBox.scrollHeight - chatBox.clientHeight;
        }
      });
    }
    
    // Create the RTCPeerConnection which knows how to talk to our
    // selected STUN/TURN server and then uses getUserMedia() to find
    // our camera and microphone and add that stream to the connection for
    // use in our video call. Then we configure event handlers to get
    // needed notifications on the call.
    async function createPeerConnection() {  
      rtcPeerConnection = new RTCPeerConnection({
        iceServers: [
          { 
            'urls': 'stun:stun.l.google.com:19302', 
          },
        ]
      });

      rtcPeerConnection.onicecandidate = (event) => 
        (event.candidate) ? connection.emit(event.candidate) : undefined;
      
      rtcPeerConnection.oniceconnectionstatechange = (event) => {
        log("*** ICE connection state changed to " + rtcPeerConnection.iceConnectionState);
        switch(rtcPeerConnection.iceConnectionState) {
          case "closed":
          case "failed":
          case "disconnected":
            closeMediaStream();
            break;
        }
      };
      
      rtcPeerConnection.onicegatheringstatechange = (event) => 
        log("*** ICE gathering state changed to: " + rtcPeerConnection.iceGatheringState);  // new, gathering, complete
      
        /**
         * stable = no ongoing offer or answer processing. RTCPeerConnection object is new if  both localDescription and remoteDescription are null; or negotiation is complete and a connection has been established.
         * have-local-offer = The local peer has called RTCPeerConnection.setLocalDescription(), passing in SDP representing an offer (usually created by calling RTCPeerConnection.createOffer()), and the offer has been applied successfully.
         * have-remote-offer = The remote peer has created an offer and used the signaling server to deliver it to the local peer, which has set the offer as the remote description by calling RTCPeerConnection.setRemoteDescription().
         * have-local-pranswer = The offer sent by the remote peer has been applied and an answer has been created (usually by calling RTCPeerConnection.createAnswer()) and applied by calling RTCPeerConnection.setLocalDescription(). This provisional answer describes the supported media formats and so forth, but may not have a complete set of ICE candidates included. Further candidates will be delivered separately later.
         * have-remote-pranswer = A provisional answer has been received and successfully applied in response to an offer previously sent and established by calling setLocalDescription().
         * closed = The RTCPeerConnection has been closed. 
         **/
      rtcPeerConnection.onsignalingstatechange = (event) => 
        (rtcPeerConnection.signalingState === 'closed') 
          ? closeMediaStream() 
          : undefined;

      // Called on begin, resume, restart.      
      rtcPeerConnection.onnegotiationneeded = async () => {
        try {
          const offer = await rtcPeerConnection.createOffer();    
          if (rtcPeerConnection.signalingState != "stable") { return; };
          await rtcPeerConnection.setLocalDescription(offer);
          connection.emit("sdp", rtcPeerConnection.localDescription)

        } catch(err) {
          log("*** The following error occurred while handling the negotiationneeded event:");
          reportError(err);
        };
      };
    }
        
    function closeMediaStream() {
      if (rtcPeerConnection) {
        log("--> Closing the peer connection");
    
        rtcPeerConnection.ontrack = null;
        rtcPeerConnection.onnicecandidate = null;
        rtcPeerConnection.oniceconnectionstatechange = null;
        rtcPeerConnection.onsignalingstatechange = null;
        rtcPeerConnection.onicegatheringstatechange = null;
        rtcPeerConnection.onnotificationneeded = null;

        rtcPeerConnection.getTransceivers().forEach( transceiver => transceiver.stop() );
        //mediaStream.getTracks().forEach(track => track.stop() ) redundant maybe
        rtcPeerConnection.close();
        rtcPeerConnection = null;
        mediaStream = null;
      }
    
      document.getElementById("hangup-button").disabled = true;
    }
          
    async function invite(evt) {
      if (rtcPeerConnection) {
        alert("You can't start a call because you already have one open!");
      } else {
        createPeerConnection();
        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaStream.getTracks().forEach(
            track => rtcPeerConnection.addTransceiver(track, { streams: [mediaStream] })
          );
        } catch(err) {
          handleGetUserMediaError(err);
        }
      }
    }
    
    // RTCSdpType {
    //    "offer",
    //    "pranswer",
    //    "answer",
    //    "rollback"
    // };

    async function handleAnswerMsg(msg) {   
      const sdp = new RTCSessionDescription(msg.sdp);
      rtcPeerConnection.setRemoteDescription(sdp).catch(reportError);
    }
    
    // A new ICE candidate has been received from the other peer. Call
    // RTCPeerConnection.addIceCandidate() to send it along to the
    // local ICE framework.
    async function handleNewICECandidateMsg(msg) {
      const candidate = new RTCIceCandidate(msg.candidate);
      log("*** Adding received ICE candidate: " + JSON.stringify(candidate));
      rtcPeerConnection.addIceCandidate(candidate).catch(reportError)
    }
    
    // Handle errors which occur when trying to access the local media
    // hardware; that is, exceptions thrown by getUserMedia(). The two most
    // likely scenarios are that the user has no camera and/or microphone
    // or that they declined to share their equipment when prompted. If
    // they simply opted not to share their media, that's not really an
    // error, so we won't present a message in that situation.
    
    function handleGetUserMediaError(e) {
      log_error(e);
      switch(e.name) {
        case "NotFoundError":
          alert("Unable to open your call because no camera and/or microphone" +
                "were found.");
          break;
        case "SecurityError":
        case "PermissionDeniedError":
          break;
        default:
          alert("Error opening your camera and/or microphone: " + e.message);
          break;
      }
      closeMediaStream();
    }
    
    // Handles reporting errors. Currently, we just dump stuff to console but
    // in a real-world application, an appropriate (and user-friendly)
    // error message should be displayed.
    
    function reportError(errMessage) {
      log_error(`Error ${errMessage.name}: ${errMessage.message}`);
    }
    
        </script>
</head>
<body>
    <div class="container">
        <div class="infobox">
          <p>This is a simple chat system implemented using WebSockets. It works by sending packets of JSON back and forth with the server.
            <a href="https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat">
          Check out the source</a> on Github.</p>
          <p class="mdn-disclaimer">This text and audio/video chat example is offered as-is for demonstration purposes only, and should not be used for any other purpose.
          </p>
          <p>Click a username in the user list to ask them to enter a one-on-one video chat with you.</p>
          <p>Enter a username: <input id="name" type="text" maxlength="12" required autocomplete="username" inputmode="verbatim" placeholder="Username">
            <input type="button" name="login" value="Log in" onclick="connect()"></p>
        </div>
        <ul class="userlistbox"></ul>
        <div class="chatbox"></div>
        <div class="camerabox">
          <video id="received_video" autoplay></video>
          <video id="local_video" autoplay muted></video>
          <button id="hangup-button" onclick="hangUpCall();" role="button" disabled>
            Hang Up
          </button>
        </div>
        <div class="empty-container"></div>
        <div class="chat-controls">
          Chat:<br/>
          <input id="text" type="text" name="text" size="100" maxlength="256" placeholder="Say something meaningful..." autocomplete="off" onkeyup="handleKey(event)" disabled>
          <input type="button" id="send" name="send" value="Send" onclick="handleSendButton()" disabled>
        </div>
      </div>
    
</body>
</html>