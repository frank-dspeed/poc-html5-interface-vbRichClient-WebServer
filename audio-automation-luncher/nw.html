<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REMOTE-MIC Control Panel</title>
    <script>
    if (window.require) {
        require('./index.js')
        import('./node_modules/socket.io/client-dist/socket.io.esm.min.js').then(m=>window.io = m.io)
    } else {
        import('./socket.io/socket.io.esm.min.js').then(m=>window.io = m.io)
    }
    </script>
    <script>
    
    // WebSocket chat/signaling channel variables.

    var connection = null;
    var clientID = 0;
    
    // The media constraints object describes what sort of stream we want
    // to request from the local A/V hardware (typically a  and
    // microphone). Here, we specify only that we want both audio and
    // video; however, you can be more specific. It's possible to state
    // that you would prefer (or require) specific resolutions of video,
    // whether to prefer the user-facing or rear-facing camera (if available),
    // and so on.
    //
    // See also:
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
    //
    
    var mediaConstraints = {
      audio: true,            // We want an audio track
      // video: {
      //   aspectRatio: {
      //     ideal: 1.333333     // 3:2 aspect is preferred
      //   }
      // }
    };
    
    var rtcPeerConnection = null; // RTCPeerConnection
    
    var mediaStream = null;       // MediaStream
    
    // Output logging information to console.
    function log(text) {
      var time = new Date();
    
      console.log("[" + time.toLocaleTimeString() + "] " + text);
    }
    
    // Output an error message to console.
    
    function log_error(text) {
      var time = new Date();
    
      console.trace("[" + time.toLocaleTimeString() + "] " + text);
    }
    
    // Send a JavaScript object by converting it to JSON and sending
    // it as a message on the WebSocket connection.
    
    function sendToServer(msg) {
      var msgJSON = JSON.stringify(msg);
    
      log("Sending '" + msg.type + "' message: " + msgJSON);
      connection.send(msgJSON);
    }
    
    // Called when the "id" message is received; this message is sent by the
    // server to assign this login session a unique ID number; in response,
    // this function sends a "username" message to set our username for this
    // session.
    function setUsername() {
      myUsername = document.getElementById("name").value;
      sendToServer({
        name: myUsername,
        date: Date.now(),
        id: clientID,
        type: "username"
      });
    }
    
    // Open and configure the connection to the WebSocket server.
    
    function connect() {
      serverUrl = "wss://localhost:8080/webRTC";
    
      log(`Connecting to server: ${serverUrl}`);
      //connection = new WebSocket(serverUrl, "json");
      connection = io(serverUrl, { transports: ['websocket'], rejectUnauthorized: false });
      connection.on("connect", () => {
        document.getElementById("text").disabled = false;
        document.getElementById("send").disabled = false;
      });
    
      connection.on('error', function(evt) {
        console.dir(evt);
      })
      connection.on('webrtc', function(evt) {
        console.log('webrtc',evt)
      })
      // onConnect emit socketid to namespace      
      // connection.on('id', (clientID) => {
      //   connection.emit('id', {
      //     name: document.getElementById("name").value,
      //     date: Date.now(),
      //     id: clientID,
      //     type: "username"
      //   });
      // })
      
      connection.on('message', function(msg) {
        
        var chatBox = document.querySelector(".chatbox");
        var text = "";
        
        log("Message received: ");
        console.dir(msg);
        var time = new Date(msg.date);
        var timeStr = time.toLocaleTimeString();
    
        switch(msg.type) {   
          case "video-offer":  // Invitation and offer to chat
            acceptOffer(msg);
            break;
    
          case "video-answer":  // Callee has answered our offer
            var desc = new RTCSessionDescription(msg.sdp);
            await rtcPeerConnection.setRemoteDescription(desc).catch(reportError);           
            break;
    
          case "new-ice-candidate": // A new ICE candidate has been received
            handleNewICECandidateMsg(msg);
            break;
    
          case "hang-up": // The other peer has hung up the call
            handleHangUpMsg(msg);
            break;
    
          // Unknown message; output to console for debugging.
    
          default:
            log_error("Unknown message received:");
            log_error(msg);
        }
    
        // If there's text to insert into the chat buffer, do so now, then
        // scroll the chat panel so that the new text is visible.
    
        if (text.length) {
          chatBox.innerHTML += text;
          chatBox.scrollTop = chatBox.scrollHeight - chatBox.clientHeight;
        }
      });
    }
    
    // Create the RTCPeerConnection which knows how to talk to our
    // selected STUN/TURN server and then uses getUserMedia() to find
    // our camera and microphone and add that stream to the connection for
    // use in our video call. Then we configure event handlers to get
    // needed notifications on the call.
    async function createPeerConnection() {  
      rtcPeerConnection = new RTCPeerConnection({
        iceServers: [
          { 
            'urls': 'stun:stun.l.google.com:19302', 
          },
        ]
      });

      rtcPeerConnection.onicecandidate = (event) => 
        (event.candidate) ? connection.send(event.candidate) : undefined;
      
      rtcPeerConnection.oniceconnectionstatechange = (event) => {
        log("*** ICE connection state changed to " + rtcPeerConnection.iceConnectionState);
        switch(rtcPeerConnection.iceConnectionState) {
          case "closed":
          case "failed":
          case "disconnected":
            closeMediaStream();
            break;
        }
      };
      
      rtcPeerConnection.onicegatheringstatechange = (event) => 
        log("*** ICE gathering state changed to: " + rtcPeerConnection.iceGatheringState);  // new, gathering, complete
      

      rtcPeerConnection.onsignalingstatechange = (event) => 
        /**
         * stable = no ongoing offer or answer processing. RTCPeerConnection object is new if  both localDescription and remoteDescription are null; or negotiation is complete and a connection has been established.
         * have-local-offer = The local peer has called RTCPeerConnection.setLocalDescription(), passing in SDP representing an offer (usually created by calling RTCPeerConnection.createOffer()), and the offer has been applied successfully.
         * have-remote-offer = The remote peer has created an offer and used the signaling server to deliver it to the local peer, which has set the offer as the remote description by calling RTCPeerConnection.setRemoteDescription().
         * have-local-pranswer = The offer sent by the remote peer has been applied and an answer has been created (usually by calling RTCPeerConnection.createAnswer()) and applied by calling RTCPeerConnection.setLocalDescription(). This provisional answer describes the supported media formats and so forth, but may not have a complete set of ICE candidates included. Further candidates will be delivered separately later.
         * have-remote-pranswer = A provisional answer has been received and successfully applied in response to an offer previously sent and established by calling setLocalDescription().
         * closed = The RTCPeerConnection has been closed. 
         **/
        (rtcPeerConnection.signalingState === 'closed') 
          ? closeMediaStream() 
          : undefined;

      // Called on begin, resume, restart.      
      rtcPeerConnection.onnegotiationneeded = async () => {
        try {
          const offer = await rtcPeerConnection.createOffer();    
          if (rtcPeerConnection.signalingState != "stable") { return; }
          await rtcPeerConnection.setLocalDescription(offer);
          const sdp = rtcPeerConnection.localDescription
          connection.send(sdp)
        } catch(err) {
          log("*** The following error occurred while handling the negotiationneeded event:");
          reportError(err);
        };
      };

      // {RTCRtpReceiver} receiver
      // {MediaStreamTrack} track
      // {MediaStream[]} streams
      // {RTCRtpTransceiver} transceiver
      //
      // In our case, we're just taking the first stream found and attaching it to the <audio> element for incoming media.
      rtcPeerConnection.ontrack = (event) => {
        log("*** Track event");
        document.getElementById("received_video").srcObject = event.streams[0];
        document.getElementById("hangup-button").disabled = false;
      };
    }
    
       
    // Close the RTCPeerConnection and reset variables so that the user can
    // make or receive another call if they wish. This is called both
    // when the user hangs up, the other user hangs up, or if a connection
    // failure is detected.
    
    function closeMediaStream() {
      if (rtcPeerConnection) {
        log("--> Closing the peer connection");
    
        // Disconnect all our event listeners; we don't want stray events
        // to interfere with the hangup while it's ongoing.
    
        rtcPeerConnection.ontrack = null;
        rtcPeerConnection.onnicecandidate = null;
        rtcPeerConnection.oniceconnectionstatechange = null;
        rtcPeerConnection.onsignalingstatechange = null;
        rtcPeerConnection.onicegatheringstatechange = null;
        rtcPeerConnection.onnotificationneeded = null;

        rtcPeerConnection.getTransceivers().forEach( transceiver => transceiver.stop() );
    
        var localVideo = document.getElementById("local_video");
        if (localVideo.srcObject) {
          localVideo.pause();
          localVideo.srcObject.getTracks().forEach(track => track.stop() );
        }
    
        rtcPeerConnection.close();
        rtcPeerConnection = null;
        mediaStream = null;
      }
    
      document.getElementById("hangup-button").disabled = true;
    }
          
    async function invite(evt) {
      if (rtcPeerConnection) {
        alert("You can't start a call because you already have one open!");
      } else {
        createPeerConnection();
        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaStream.getTracks().forEach(
            track => rtcPeerConnection.addTransceiver(track, {streams: [mediaStream]})
          );
        } catch(err) {
          handleGetUserMediaError(err);
        }
      }
    }
    
        //RTCSdpType {
        //   "offer",
        //   "pranswer",
        //   "answer",
        //   "rollback"
        //};


    // Accept an offer to video chat. We configure our local settings,
    // create our RTCPeerConnection, get and attach our local
    // stream, then create and send an answer to the caller.
    async function acceptOffer(msg) {
      if (!rtcPeerConnection) {
        createPeerConnection();
      }
        
      var desc = new RTCSessionDescription(msg.sdp);
    
      // If the connection isn't stable yet, wait for it...
      if (rtcPeerConnection.signalingState != "stable") {
        // Set the local and remote descriptions for rollback; don't proceed until both return.
        await Promise.all([
          rtcPeerConnection.setLocalDescription({type: "rollback"}),
          rtcPeerConnection.setRemoteDescription(desc)
        ]);
        return;
      }
    
      await rtcPeerConnection.setRemoteDescription(desc);
    
      // Get the  stream if we don't already have it
      // if (!mediaStream) {
      //   try {
      //     mediaStream = await navigator.mediaDevices.getUserMedia(mediaConstraints);
      //   } catch(err) {
      //     handleGetUserMediaError(err);
      //     return;
      //   }
    
      //   document.getElementById("local_video").srcObject = mediaStream;  
      //   try {
      //     mediaStream.getTracks().forEach( (track) => rtcPeerConnection.addTransceiver(track, {streams: [mediaStream]}) );
      //   } catch(err) {
      //     handleGetUserMediaError(err);
      //   }
      // }
      await rtcPeerConnection.setLocalDescription(await rtcPeerConnection.createAnswer());
      connection.send(rtcPeerConnection.localDescription); // answer
      
    }
    
    // Responds to the "video-answer" message sent to the caller
    // once the callee has decided to accept our request to talk.
    
    async function handleVideoAnswerMsg(msg) {   
      var desc = new RTCSessionDescription(msg.sdp);
      await rtcPeerConnection.setRemoteDescription(desc).catch(reportError);
    }
    
    // A new ICE candidate has been received from the other peer. Call
    // RTCPeerConnection.addIceCandidate() to send it along to the
    // local ICE framework.
    
    async function handleNewICECandidateMsg(msg) {
      var candidate = new RTCIceCandidate(msg.candidate);
    
      log("*** Adding received ICE candidate: " + JSON.stringify(candidate));
      try {
        await rtcPeerConnection.addIceCandidate(candidate)
      } catch(err) {
        reportError(err);
      }
    }
    
    // Handle errors which occur when trying to access the local media
    // hardware; that is, exceptions thrown by getUserMedia(). The two most
    // likely scenarios are that the user has no camera and/or microphone
    // or that they declined to share their equipment when prompted. If
    // they simply opted not to share their media, that's not really an
    // error, so we won't present a message in that situation.
    
    function handleGetUserMediaError(e) {
      log_error(e);
      switch(e.name) {
        case "NotFoundError":
          alert("Unable to open your call because no camera and/or microphone" +
                "were found.");
          break;
        case "SecurityError":
        case "PermissionDeniedError":
          // Do nothing; this is the same as the user canceling the call.
          break;
        default:
          alert("Error opening your camera and/or microphone: " + e.message);
          break;
      }
    
      // Make sure we shut down our end of the RTCPeerConnection so we're
      // ready to try again.
    
      closeMediaStream();
    }
    
    // Handles reporting errors. Currently, we just dump stuff to console but
    // in a real-world application, an appropriate (and user-friendly)
    // error message should be displayed.
    
    function reportError(errMessage) {
      log_error(`Error ${errMessage.name}: ${errMessage.message}`);
    }
    
        </script>
</head>
<body>
    <div class="container">
        <div class="infobox">
          <p>This is a simple chat system implemented using WebSockets. It works by sending packets of JSON back and forth with the server.
            <a href="https://github.com/mdn/samples-server/tree/master/s/webrtc-from-chat">
          Check out the source</a> on Github.</p>
          <p class="mdn-disclaimer">This text and audio/video chat example is offered as-is for demonstration purposes only, and should not be used for any other purpose.
          </p>
          <p>Click a username in the user list to ask them to enter a one-on-one video chat with you.</p>
          <p>Enter a username: <input id="name" type="text" maxlength="12" required autocomplete="username" inputmode="verbatim" placeholder="Username">
            <input type="button" name="login" value="Log in" onclick="connect()"></p>
        </div>
        <ul class="userlistbox"></ul>
        <div class="chatbox"></div>
        <div class="camerabox">
          <video id="received_video" autoplay></video>
          <video id="local_video" autoplay muted></video>
          <button id="hangup-button" onclick="hangUpCall();" role="button" disabled>
            Hang Up
          </button>
        </div>
        <div class="empty-container"></div>
        <div class="chat-controls">
          Chat:<br/>
          <input id="text" type="text" name="text" size="100" maxlength="256" placeholder="Say something meaningful..." autocomplete="off" onkeyup="handleKey(event)" disabled>
          <input type="button" id="send" name="send" value="Send" onclick="handleSendButton()" disabled>
        </div>
      </div>
    
</body>
</html>